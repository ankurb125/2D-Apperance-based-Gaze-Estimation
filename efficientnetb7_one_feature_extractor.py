# -*- coding: utf-8 -*-
"""EfficientNetB7_one_feature_extractor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19M4wLtY9avLn6rwyLnhqwBKkrdZybhwf
"""

from sklearn.preprocessing import LabelBinarizer
from sklearn.preprocessing import MinMaxScaler
import pandas as pd
import numpy as np
import glob
import cv2
from matplotlib import pyplot as plt
import os
from PIL import Image

from keras.optimizers import Adam
from sklearn.model_selection import train_test_split
# !pip install tensorflow==2.9.0
import tensorflow as tf
# from tensorflow.keras.layers.experimental import preprocessing
# from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import (
    BatchNormalization, SeparableConv2D, MaxPooling2D, Activation, Flatten, Dropout, Dense, Input, Conv2D,concatenate
)
from tensorflow.keras import backend as K

from keras.models import Sequential
from keras.models import Model
print(tf.__version__)

df = pd.read_csv('reference.csv')
df

from google.colab import drive
drive.mount('/content/drive')

def process_images(df,inputPath):
    images=[]
    for i in range(len(df)):
        pre = df['Filepath'][i].split('_')[0]
        suf = df['Filepath'][i].split('_')[1].split('.')[0]
        basePath = os.path.sep.join([inputPath,"{}_{}_*".format(pre,suf)])
        imgPaths = sorted(list(glob.glob(basePath)))
        inputImages =[]
        outputImage = np.zeros((256,256,3),dtype='uint8')
        for imgPath in imgPaths:
            image = cv2.imread(imgPath)
            image = cv2.resize(image, (128, 128))
            inputImages.append(image)
        outputImage[0:128, 0:128] = inputImages[2]
        outputImage[0:128, 128:256] = inputImages[0]
        outputImage[128:256, 128:256] = inputImages[1]
        outputImage[128:256, 0:128] = inputImages[3]
        images.append(outputImage)
    return np.array(images)

images = process_images(df, 'drive/MyDrive/images/')
images = images / 255.0
plt.imshow(images[198])

df1 = df.iloc[:,4:]

df1

split = train_test_split(df1, images, test_size=0.2, random_state=123)
(y_train, y_test, x_train, x_test) = split
y_train, y_val, x_train, x_val = train_test_split(y_train, x_train, test_size=0.1, random_state=123)

x_train.shape, y_train.shape, x_val.shape, y_val.shape, x_test.shape, y_test.shape

base_model = tf.keras.applications.EfficientNetB7(weights=None, include_top=False, input_shape=(64, 64, 3))

for layer in base_model.layers:
    layer.trainable = False

for i, layer in enumerate(base_model.layers):
    print(i, layer.name, layer.trainable)

x = base_model.output
x = Flatten()(x) 
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(64, activation='relu')(x)
x = Dense(2, activation='linear')(x) 
efficient_model = Model(inputs=base_model.input, outputs=x)

from keras.callbacks import ReduceLROnPlateau
from keras.callbacks import ModelCheckpoint
lr_reduce = ReduceLROnPlateau(monitor='val_root_mean_squared_error', factor=0.6, patience=8, verbose=1, mode='min', min_lr=5e-5)
checkpoint = ModelCheckpoint('EfficientNetB7_one_feature_extractor_finetune.h15', monitor= 'val_root_mean_squared_error', mode= 'min', save_best_only = True, verbose= 1)

from tensorflow.keras import layers, models, Model, optimizers
learning_rate= 5e-5
final_model.compile(loss="mse", optimizer=optimizers.Adam(lr=learning_rate), metrics=["RootMeanSquaredError"])
history = transfer_model.fit(x_train,y_train, batch_size = 20, epochs=50, validation_data=(x_val,y_val), callbacks=[lr_reduce,checkpoint])

plt.figure(figsize=(5,5))
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.legend(['loss','val_loss'], loc='upper right',prop={'size': 15});
plt.title('Learning curve for the training of Dense Layers', fontsize=15)
plt.show()

preds = transfer_model.predict(x_test)
y_test_flatten = y_test.to_numpy()

for i in range(len(preds)):
    print(preds[i], y_test_flatten[i])

m = tf.keras.metrics.RootMeanSquaredError()
m.update_state(preds, y_test_flatten)
m.result().numpy()