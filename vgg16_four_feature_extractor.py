# -*- coding: utf-8 -*-
"""VGG16_four_feature_extractor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1smvmUYWKvzTgayUy5zJNEDs5rtX3QcGO
"""

from sklearn.preprocessing import LabelBinarizer
from sklearn.preprocessing import MinMaxScaler
import pandas as pd
import numpy as np
import glob
import cv2
from matplotlib import pyplot as plt
import os
from PIL import Image

from keras.optimizers import Adam
from sklearn.model_selection import train_test_split

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import (
    BatchNormalization, SeparableConv2D, MaxPooling2D, Activation, Flatten, Dropout, Dense, Input, Conv2D,
    concatenate
)
from tensorflow.keras import backend as K
from tensorflow.keras import activations
from keras.models import Sequential
from keras.models import Model

df = pd.read_csv('reference.csv')
df

from google.colab import drive
drive.mount('/content/drive')

def process_images(df,inputPath):
    original_images=[]
    face_images=[]
    left_eye_images=[]
    right_eye_images=[]
    for i in range(len(df)):
        pre = df['Filepath'][i].split('_')[0]
        suf = df['Filepath'][i].split('_')[1].split('.')[0]
        basePath = os.path.sep.join([inputPath,"{}_{}_*".format(pre,suf)])
        imgPaths = sorted(list(glob.glob(basePath)))
        inputImages =[]
        for i in range(0,len(imgPaths),4):
            fimage = cv2.imread(imgPaths[i])
            fimage = cv2.resize(fimage, (256,256))
            limage = cv2.imread(imgPaths[i+1])
            limage = cv2.resize(limage, (256, 256))
            oimage = cv2.imread(imgPaths[i+2])
            oimage = cv2.resize(oimage, (256, 256))
            rimage = cv2.imread(imgPaths[i+3])
            rimage = cv2.resize(rimage, (256, 256))
            original_images.append(oimage)
            left_eye_images.append(limage)
            right_eye_images.append(rimage)
            face_images.append(fimage)
    return np.array(original_images),np.array(left_eye_images),np.array(right_eye_images),np.array(face_images)

original_images,left_eye_images,right_eye_images,face_images = process_images(df, 'drive/MyDrive/images/')
original_images = original_images / 255.0
left_eye_images = left_eye_images / 255.0
right_eye_images = right_eye_images / 255.0
face_images = face_images / 255.0

plt.imshow(face_images[489])

df1 = df.iloc[:,4:]
df1

y_train_ori, y_test_ori, x_train_ori, x_test_ori = train_test_split(df1, original_images, test_size=0.2, random_state=123)
y_train_ori, y_val_ori, x_train_ori, x_val_ori = train_test_split(y_train_ori, x_train_ori, test_size=0.1, random_state=123)
y_train_fac, y_test_fac, x_train_fac, x_test_fac = train_test_split(df1, face_images, test_size=0.2, random_state=123)
y_train_fac, y_val_fac, x_train_fac, x_val_fac = train_test_split(y_train_fac, x_train_fac, test_size=0.1, random_state=123)
y_train_lef, y_test_lef, x_train_lef, x_test_lef = train_test_split(df1, left_eye_images, test_size=0.2, random_state=123)
y_train_lef, y_val_lef, x_train_lef, x_val_lef = train_test_split(y_train_lef, x_train_lef, test_size=0.1, random_state=123)
y_train_rig, y_test_rig, x_train_rig, x_test_rig = train_test_split(df1, right_eye_images, test_size=0.2, random_state=123)
y_train_rig, y_val_rig, x_train_rig, x_val_rig = train_test_split(y_train_rig, x_train_rig, test_size=0.1, random_state=123)

print('Original Image',x_train_ori.shape, y_train_ori.shape, x_val_ori.shape, y_val_ori.shape, x_test_ori.shape, y_test_ori.shape)
print('Face Image',x_train_fac.shape, y_train_fac.shape, x_val_fac.shape, y_val_fac.shape, x_test_fac.shape, y_test_fac.shape)
print('Left eye Image',x_train_lef.shape, y_train_lef.shape, x_val_lef.shape, y_val_lef.shape, x_test_lef.shape, y_test_lef.shape)
print('Original Image',x_train_rig.shape, y_train_rig.shape, x_val_rig.shape, y_val_rig.shape, x_test_rig.shape, y_test_rig.shape)

"""## Fine-Tuning VGG"""

b1 = tf.keras.applications.vgg16.VGG16(weights=None, include_top=False, input_shape=(64, 64, 3))
b2 = tf.keras.applications.vgg16.VGG16(weights=None, include_top=False, input_shape=(64, 64, 3))
b3 = tf.keras.applications.vgg16.VGG16(weights=None, include_top=False, input_shape=(64, 64, 3))
b4 = tf.keras.applications.vgg16.VGG16(weights=None, include_top=False, input_shape=(64, 64, 3))

for layer in b1.layers[:15]:
    layer.trainable = False
    layer._name = layer._name + '_vgg19_1f'
for layer in b2.layers[:15]:
    layer.trainable = False
    layer._name = layer._name + '_vgg19_2f'
for layer in b3.layers[:15]:
    layer.trainable = False
    layer._name = layer._name + '_vgg19_3f'
for layer in b4.layers[:15]:
    layer.trainable = False
    layer._name = layer._name + '_vgg19_4f'
for layer in b1.layers[15:]:
    layer.trainable = True
    layer._name = layer._name + '_vgg19_1'
for layer in b2.layers[15:]:
    layer.trainable = True
    layer._name = layer._name + '_vgg19_2'
for layer in b3.layers[15:]:
    layer.trainable = True
    layer._name = layer._name + '_vgg19_3'
for layer in b4.layers[15:]:
    layer.trainable = True
    layer._name = layer._name + '_vgg19_4'

x1 = b1.output
x2 = b2.output
x3 = b3.output
x4 = b4.output
concate_input=concatenate([x1,x2,x3,x4])
x = Flatten()(concate_input) 
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(64, activation='relu')(x)
x = Dense(2, activation='linear')(x) 
final_model = Model(inputs=[b1.input,b2.input,b3.input,b4.input], outputs=x)

from keras.callbacks import ReduceLROnPlateau
from keras.callbacks import ModelCheckpoint
lr_reduce = ReduceLROnPlateau(monitor='val_root_mean_squared_error', factor=0.6, patience=8, verbose=1, mode='min', min_lr=5e-5)
checkpoint = ModelCheckpoint('VGG16_four_feature_extractor_finetune.h15', monitor= 'val_root_mean_squared_error', mode= 'min', save_best_only = True, verbose= 1)

x_val = (x_val_ori,x_val_fac,x_val_lef,x_val_rig)
x_train =(x_train_ori,x_train_fac,x_train_lef,x_train_rig)
y_train = (y_train_ori,y_train_fac,y_train_lef,y_train_rig)
y_val = (y_val_ori,y_val_fac,y_val_lef,y_val_rig)
x_test =(x_test_ori,x_test_fac,x_test_lef,x_test_rig)

from tensorflow.keras import layers, models, Model, optimizers
learning_rate= 5e-5
final_model.compile(loss="mse", optimizer=optimizers.Adam(lr=learning_rate), metrics=["RootMeanSquaredError"])
history = final_model.fit(x_train,y_train, batch_size = 32, epochs=200, validation_data=(x_val,y_val), callbacks=[lr_reduce,checkpoint])

plt.figure(figsize=(5,5))
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.legend(['loss','val_loss'], loc='upper right',prop={'size': 15});
plt.title('Learning curve for the training of Dense Layers', fontsize=15)
plt.show()

preds = final_model.predict(x_test)
y_test_flatten = y_test_ori.to_numpy()

for i in range(len(preds)):
    print(preds[i], y_test_flatten[i])

m = tf.keras.metrics.RootMeanSquaredError()
m.update_state(preds, y_test_flatten)
m.result().numpy()

"""## Fine-Tuning VGG-16 Model with data Augmentation"""

x = base_model.output
x = Flatten()(x)
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(256, activation='relu')(x)
x = Dense(2, activation='linear')(x) 
vgg_model = Model(inputs=base_model.input, outputs=x)
for i, layer in enumerate(base_model.layers):
    print(i, layer.name, layer.trainable)

from keras.preprocessing.image import ImageDataGenerator
train_datagen = ImageDataGenerator(brightness_range= [0.7, 1.3])
train_generator = train_datagen.flow(x_train,y_train,batch_size=10)
vgg_model.compile(loss="mse", optimizer='adam', metrics=["RootMeanSquaredError"])
history = vgg_model.fit_generator(train_generator, validation_data=(x_val,y_val), epochs=50, shuffle=True, callbacks=[lr_reduce],verbose=1)

plt.figure(figsize=(10,10))
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.legend(['loss','val_loss'], loc='upper right',prop={'size': 15});
plt.title('Learning curve for the training of Dense Layers', fontsize=15)
plt.show()

preds = vgg_model.predict(x_test)
y_test_flatten = y_test.to_numpy()

for i in range(len(preds)):
    print(preds[i], y_test_flatten[i])

