# -*- coding: utf-8 -*-
"""VGG16_one_feature_extractor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1guBDA1cKcYb5cVZBYdsvemWsBV4R0zAo
"""

from sklearn.preprocessing import LabelBinarizer
from sklearn.preprocessing import MinMaxScaler
import pandas as pd
import numpy as np
import glob
import cv2
from matplotlib import pyplot as plt
import os
from PIL import Image

from keras.optimizers import Adam
from sklearn.model_selection import train_test_split

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import (
    BatchNormalization, SeparableConv2D, MaxPooling2D, Activation, Flatten, Dropout, Dense, Input, Conv2D
)
from tensorflow.keras import backend as K

from keras.models import Sequential
from keras.models import Model

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('reference.csv')
df

def process_images(df,inputPath):
    images=[]
    for i in range(len(df)):
        pre = df['Filepath'][i].split('_')[0]
        suf = df['Filepath'][i].split('_')[1].split('.')[0]
        basePath = os.path.sep.join([inputPath,"{}_{}_*".format(pre,suf)])
        imgPaths = sorted(list(glob.glob(basePath)))
        inputImages =[]
        outputImage = np.zeros((256,256,3),dtype='uint8')
        for imgPath in imgPaths:
            image = cv2.imread(imgPath)
            image = cv2.resize(image, (128, 128))
            inputImages.append(image)
        outputImage[0:128, 0:128] = inputImages[2]
        outputImage[0:128, 128:256] = inputImages[0]
        outputImage[128:256, 128:256] = inputImages[1]
        outputImage[128:256, 0:128] = inputImages[3]
        images.append(outputImage)
    return np.array(images)

images = process_images(df, 'drive/MyDrive/images/')
images = images / 255.0
plt.imshow(images[198])

df1 = df.iloc[:,4:]

df1

split = train_test_split(df1, images, test_size=0.2, random_state=123)
(y_train, y_test, x_train, x_test) = split
y_train, y_val, x_train, x_val = train_test_split(y_train, x_train, test_size=0.1, random_state=123)

x_train.shape, y_train.shape, x_val.shape, y_val.shape, x_test.shape, y_test.shape

"""## Fine-Tuning VGG"""

base_model = tf.keras.applications.vgg16.VGG16(weights=None, include_top=False, input_shape=(256, 256, 3))
base_model.summary()

for layer in base_model.layers:
    layer.trainable = False

for i, layer in enumerate(base_model.layers):
    print(i, layer.name, layer.trainable)

x = base_model.output
x = Flatten()(x) 
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(64, activation='relu')(x)
x = Dense(2, activation='linear')(x) 
vgg_model = Model(inputs=base_model.input, outputs=x)

from keras.callbacks import ReduceLROnPlateau
from keras.callbacks import ModelCheckpoint
lr_reduce = ReduceLROnPlateau(monitor='val_root_mean_squared_error', factor=0.6, patience=8, verbose=1, mode='min', min_lr=5e-5)
checkpoint = ModelCheckpoint('VGG16_256_without_weights_batch_32_finetune_no_training.h15', monitor= 'val_root_mean_squared_error', mode= 'min', save_best_only = True, verbose= 1)

from tensorflow.keras import layers, models, Model, optimizers
learning_rate= 5e-5
vgg_model.compile(loss="mse", optimizer=optimizers.Adam(lr=learning_rate), metrics=["RootMeanSquaredError"])
# history = transfer_model.fit(train_generator, batch_size = 20, epochs=50, validation_data=(x_val,y_val), callbacks=[lr_reduce,checkpoint])
history = vgg_model.fit(x_train, y_train, batch_size = 32, epochs=200, validation_data=(x_val,y_val), callbacks=[lr_reduce,checkpoint])

plt.figure(figsize=(5,5))
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.legend(['loss','val_loss'], loc='upper right',prop={'size': 15});
plt.title('Learning curve for the training of Dense Layers', fontsize=15)
plt.show()

preds = vgg_model.predict(x_test)
y_test_flatten = y_test.to_numpy()

for i in range(len(preds)):
    print(preds[i], y_test_flatten[i])

m = tf.keras.metrics.RootMeanSquaredError()
m.update_state(preds, y_test_flatten)
m.result().numpy()

"""## Fine-Tuning VGG-16 Model with data Augmentation"""

x = base_model.output
x = Flatten()(x)
x = Dense(512, activation='relu')(x)
x = Dropout(0.5)(x)
x = Dense(256, activation='relu')(x)
x = Dense(2, activation='linear')(x) 
vgg_model = Model(inputs=base_model.input, outputs=x)
for i, layer in enumerate(base_model.layers):
    print(i, layer.name, layer.trainable)

from keras.preprocessing.image import ImageDataGenerator
# def myFunc(image):
#     image = np.array(image)
#     hsv_image = cv2.cvtColor(image,cv2.COLOR_RGB2HSV)
#     return Image.fromarray(hsv_image)
train_datagen = ImageDataGenerator(brightness_range= [0.7, 1.3])
train_generator = train_datagen.flow(x_train,y_train,batch_size=10)
vgg_model.compile(loss="mse", optimizer='adam', metrics=["RootMeanSquaredError"])
history = vgg_model.fit_generator(train_generator, validation_data=(x_val,y_val), epochs=50, shuffle=True, callbacks=[lr_reduce],verbose=1)

plt.figure(figsize=(10,10))
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.legend(['loss','val_loss'], loc='upper right',prop={'size': 15});
plt.title('Learning curve for the training of Dense Layers', fontsize=15)
plt.show()

preds = vgg_model.predict(x_test)
y_test_flatten = y_test.to_numpy()

for i in range(len(preds)):
    print(preds[i], y_test_flatten[i])

